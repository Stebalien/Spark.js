<html>
<script type="text/javascript">
function Scheduler(server){
  this.server = server;
  // this object represents a map of work to time
  // it is used to do timeout analysis 
  this.mapWorkToTime = {}; 
  // this represents how long it takes before we timeout a worker
  // this time is in ms; we use this to timeout another worker 
  this.timeOutTime = 1000;

  // this map is used to map a parition to whatever is dependent on it
  // it is an array of a partition id to what is dependent on it
  this.mapPartitionToParent = {};

  // this is a map of partition id to whatever is dependent on it
  this.mapPartitionToChildren = {}; 

  // maps sequence number to status
  this.sequenceNumbers = {}
  
  // this maps a worker to the tasks that we assign it
  this.mapWorkerToTasks = {} 

  // this is the list of the targets we want to compute
  this.targets = {}

}

Scheduler.prototype = {

  //this function will remove a value from an array
  RemoveFromArray: function(arr1, value) {
    index = arr1.indexOf(value);
    if (index > -1) {
      newarray = arr1.splice(index,1);
    }
    return newarray;
  }
  
  // this function is responsible for assigning a work to a specific
  // TODO: the actual logic of this method still needs to be implemented
  AssignWorker: function(worker, task){
	// tell the worker about the task it is going to be assigned 
  } 
  
  // this function is responsible for adding a worker to the scheduler
  // TODO: this function needs to be called athe appropriate time
  AddWorker: function(worker) {
	var tasks = [];
	this.mapWorkerToTasks[worker] = tasks;
  }

  // this function is responsible for selecting the worker that should be assigned a task
  // as of now, I select the worker with the least number of tasks 
  SelctWorker : function()  {
	minTasks = 100000;
	var bestWorker = null;
        for (var key in this.mapWorkerToTasks) {
	        count = this.mapWorkerToTasks[key].length;
		if (count < minTasks){
		  bestWorker = key;
		  minTasks = count;
		}	

	}	
	return bestWorker
  }

  // this function is responsible for removing nodes from the mapPartitiontoParent
  //that do not have any parents so we can get some vertices to start with 
  Initialize: function(partitionlist) {
    for (var i = 0; i<partitionlist.length; i++) {
      partition = partition[i];
 	if (this.mapPartitionToParent[partition].length == 0) {
          delete this.mapPartitionToParent(partition);
	} 

     }
  }
 
  // this function is instrumental in pruning the total graph 
  // it starts at the targets and basically traverses the graph
  // until all of the dependencies are added 
  PruneFunction: () {
	// these are the maps that will represent the pruned maps
	var mapChildren = {}
        var mapParent = {}
	targets = this.targets
	// we are  using the targets as a queuue
	// basically waiting till it is empty
	for (targets.length == 0){
	   // taking a node and adding all of its parents in the graph
	   target = targets[0];
	   parents = this.mapPartitionToParent[target];
	   if (target not in mapParent){
		mapParent[target] = parents;
	   }
	   for (var parent in parents) {
		// adding the parent to the queue so we further iterate up the tree	
		if (targets.indexOf(parent) != -1) {
		   targets.push(parent);
		}
		// making sure that we are the children of our parent
		if (parent not in mapChildren) {
		   newArray = [target];
		   mapChildren[parent] = newarray
		}
		else{
		   mapChildren[parent].push(target)
		}
	   } 	   
	   target = RemoveFromArray(target, 0);
  	}
	this.mapPartitionToParent = mapParent;
	this.mapPartitionToChilrden = mapChildren;
  }
  // this function is responsible for removing nodes from the graph
  // we go through all of its children and remove the dependency of that child in the parent graph
  // if the child no longer has any parents, we remove it from the mapPartitionToParent
  // nodes are free to be assigned if they are not in the mapPartitionToParent but in the other map 
  RemoveNode: function(partition) {
	var children = this.mapPartitionToChildren[partition];
        for (var i = 0; i < children.length; i++) {
		child = children[i];
                this.mapPartitionToParent[child] = RemoveFromArray(this.mapPartitionToParent[child], partition)
                if (this.mapPartitionToParent[child].length == 0) {
		   delete this.mapPartitionToParent(child);
		} 
	}
        delete this.mapPartitionToChildren[partition];   
  }


  // the code that finishes the task 
  // it updates the last time we have heard from the worker
  // this also updates the worker to task map 
  FinishTask: function(workerId, task) {
      // code when one receives a new task Id
      var currentTime =  new Date().getTime();
      this.mapWorkToTime[workerId] = currentTime
      this.mapWorkerToTasks[workerId] = RemoveFromArray(this.mapWorkerToTasks[workerId], taks);	
  }
  
  // this function is responsible for generating the tasks and assigning them
  // it is using a bfs based approach so that the tasks closer to the start get started first 
  GenerateTask : function() {
	// this is the map of a partition to the number of children of it we have explored
	// this is useful so we know what a map has to be; this is useful for split 
	mapNodeToChildrenExplored = {}	
	// this is basically the queue that we need to process
        nodeQueue
	// this is useful for the map of nodes explored 
	mapNodesExplored = {}
	for (nodeQueue.length == 0) {
		sources = [];
		sinks = [];
		node = nodeQueue[0];
		for {
		   children = mapPartitionToChildren[node];
		   numChildren = children.lengh;
		   if node in mapNodeToChildrenExplored {
			// this has been computed by somebody else so we make it a source
			sources.push(node);
			int count = mapNodeToChildrenExplored[node];
			if (count < children.length) {
				newNode = children[count];
				mapNodeToChildrenExplored [node] +=1; 
				if (count + 1 != children.length) [
					nodeQueue.push(node);
				}	
			}  
		   }	  
		   else {
			 if (numChildren == 0) {
			   // we are a sink as we are the end target
			   sink.push(node);
			   break;
			 }
			 else if (numChildren == 1) {
			 // we have just one child so keep traversing
			  newNode = children[0];
			}
			else {
			  // we have more then one node and thus we have a split
			  //mark this node as a sink
			  sinks.push(node);
			  // push the node back on the queue because we are going to have to use it again
			  nodeQueue.push(node); 
                          // the map needs to be updated
			  mapNodeToChildrenExplored[node] = 1; 
			  newNode = children[0];
			}
		  }
		  // we need to check that the node we are exploring is not a join
		  parents = mapPartitionToParent[node];
		  numParents  = mapPartitionToParent[newNode].length;
		  if (numParents > 1) {
	          	if (newNode in  mapNodesExplored) {
			//we are not the first child in the join
			 this.sink.push(node);
			  break;
		    	}
			else {
			      // we are the first one in the array
			      // so we make all of the siblings sources to ensure
			      // that we wait for them
			     for (int i = 1; i < parents.length; i++) {
			       sources.push(parents[i]);
			     }
			     mapNodesExplored[newNode] = 1;
			     node = newNode;  
		
			}
		 }
		 else {
		    node = newNode;
		 }
		   
	      }
	      // creating a new task,assigning it, and removing the old node from the queue 
	      var task = new Task(sources,sinks);
	      worker = SelctWorker();
	      AssignWorker(worker,task);
	      nodeQueue = RemoveFromArray(nodeQueue, node);yy
	} 
  } 
 
  // this method is responsible for checking that the worker is done with its task 
  // if it is not done in a reasonable time, then we reassign its tasks to someone else
  AlertTimeOut : function() {
   for (var key in mapWorkToTime) {
	oldTime = mapWorkToTime[key];
	if (getTime() > oldTime + timeOutTime) {
	   console.log("we have to drop this worker)
	   tasks = this.mapWorkerToTasks[key];
	   for (var task in tasks) {
		worker = SelctWorker();
		AssignWorker(worker,tasks)
	   }
	   delete this.mapWorkerToTasks[key]
	   delete this.mapWorkToTime[key]
	}
   }
}

   //Builds partition dependencies based on json object 
  //See example-submission.json
  BuildDependencyTree: function(submission) {
    var json = JSON.parse(submission);
    
    //Check if this submission has already been added
    if !(json.seq in this.sequenceNumbers) {
      for (var i = 0; i < json.rdds.length; i++) {
        var rdd = json.rdds[i];  

        for (var j = 0; j < rdd.length; j++) {
          var partition = rdd[j];
          //Build node <- parents relationships
          if !(partition.id in this.mapPartitionToParent) {
            this.mapPartitionToParent[partition.id] = partition.dependencies;
          } else {
            this.mapPartitionToParent[partition.id] = Array.prototype.push.apply(this.mapPartitionToParent[partition.id], partition.dependencies);
          }  

	  //Build node <- children relationships
          for (var k = 0; k < partition.dependencies.length; k ++) {
            var dependency = partition.dependencies[k];
            if !(dependency in this.mapPartitionToChildren) {
              this.mapPartitionToChildren[dependency] = [partition.id];
            } else {
              this.mapPartitionToChilrden[dependency] = this.mapPartitionToChildren.push(partition.id);
            }
          }

        }
      }    
      this.sequenceNumbers[json.seq] = //ADDED?
    } 

  }

};

// this is a task class which represents a task

// the source is the partition that is in the    
// the sink is the last partition to analyze
// the nodes is a list of partitions for the worker to analyze
    
function Task(sources, sink) 
  this.sources = sources;
  this.sink = sink; 
</script>
</head>
